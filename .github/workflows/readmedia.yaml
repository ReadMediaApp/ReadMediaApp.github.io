name: Amazon Bestsellers Scraper

on:
  workflow_dispatch:  # Manual trigger
  schedule:
    # Run every Wednesday at 9 AM UTC
    - cron: '0 9 * * 3'

permissions:
  contents: write  # Allow the workflow to push changes

jobs:
  scrape-bestsellers:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        persist-credentials: true
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '24'
        cache: 'npm'
        
    - name: Install dependencies
      run: |
        npm install puppeteer cheerio
        
    - name: Create focused bestsellers scraper
      run: |
        cat > bestsellers-scraper.js << 'EOF'
        const puppeteer = require('puppeteer');
        const fs = require('fs');
        const path = require('path');

        const currentYear = new Date().getFullYear();
        const AFFILIATE_ID = process.env.AFFILIATE_ID || 'readmediaapp-20';
        const DATA_DIR = 'data';
        const OUTPUT_FILE = path.join(DATA_DIR, 'amazon-recommendations.json');

        // Focused bestseller categories with clean URLs
        const BESTSELLER_CATEGORIES = {
          // Fiction Categories
          'fiction_literary': 'https://www.amazon.com/Best-Sellers-Books-Literary-Fiction/zgbs/books/17',
          
          // Non-Fiction Categories
          'nonfiction_biographies': 'https://www.amazon.com/Best-Sellers-Books-Biographies-Memoirs/zgbs/books/2',
          
          // Self-Improvement
          'self_improvement_personal_growth': 'https://www.amazon.com/Best-Sellers-Books-Personal-Development/zgbs/books/4736',
          
          // Religion & Spirituality
          'religion_christianity': 'https://www.amazon.com/Best-Sellers-Books-Christian-Books/zgbs/books/12290'
        };

        // Utility function for delays
        function delay(ms) {
          return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Ensure data directory exists
        if (!fs.existsSync(DATA_DIR)) {
          fs.mkdirSync(DATA_DIR, { recursive: true });
        }

        // Load existing data
        function loadExistingData() {
          try {
            if (fs.existsSync(OUTPUT_FILE)) {
              const data = JSON.parse(fs.readFileSync(OUTPUT_FILE, 'utf8'));
              console.log(`üìä Found existing data: ${data.metadata.totalBooks} books across ${data.metadata.categoriesCount} categories`);
              return data;
            }
          } catch (error) {
            console.log('No existing data found, starting fresh...');
          }
          
          return {
            lastUpdated: new Date().toISOString(),
            categories: {},
            metadata: {
              totalBooks: 0,
              categoriesCount: 0,
              affiliateId: AFFILIATE_ID,
              source: 'GitHub Actions Bestsellers Scraper',
              scrapeYear: currentYear,
              exportDate: new Date().toISOString()
            }
          };
        }

        // Scrape bestsellers from a category page
        async function scrapeBestsellersPage(category, categoryUrl) {
          console.log(`\nüåê Scraping ${category} bestsellers...`);
          
          const browser = await puppeteer.launch({
            headless: true,
            args: [
              '--no-sandbox',
              '--disable-setuid-sandbox',
              '--disable-blink-features=AutomationControlled',
              '--disable-dev-shm-usage',
              '--disable-accelerated-2d-canvas',
              '--no-first-run',
              '--no-zygote',
              '--disable-gpu',
              '--window-size=1920,1080',
              '--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            ]
          });
          
          try {
            const page = await browser.newPage();
            
            // Enhanced stealth mode
            await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
            await page.setViewport({ width: 1920, height: 1080 });
            
            // Additional headers to appear more human
            await page.setExtraHTTPHeaders({
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
              'Accept-Language': 'en-US,en;q=0.9',
              'Accept-Encoding': 'gzip, deflate, br',
              'Cache-Control': 'no-cache',
              'Connection': 'keep-alive',
            });

            // Bypass automation detection
            await page.evaluateOnNewDocument(() => {
              Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
              Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3, 4, 5] });
              Object.defineProperty(navigator, 'languages', { get: () => ['en-US', 'en'] });
            });

            console.log(`üì¶ Navigating to: ${categoryUrl}`);
            
            try {
              await page.goto(categoryUrl, { 
                waitUntil: 'networkidle2',
                timeout: 60000 
              });
            } catch (error) {
              console.log(`‚ö†Ô∏è  Navigation timeout, trying domcontentloaded...`);
              await page.goto(categoryUrl, { 
                waitUntil: 'domcontentloaded',
                timeout: 60000 
              });
            }

            // Wait for page to settle
            await delay(4000);

            // Check if we got blocked
            const currentUrl = page.url();
            const pageTitle = await page.title();
            
            console.log(`üìÑ Current URL: ${currentUrl}`);
            console.log(`üìñ Page title: ${pageTitle}`);

            if (currentUrl.includes('robot') || currentUrl.includes('captcha') || pageTitle.includes('Robot Check')) {
              console.log('‚ùå BLOCKED: Amazon is showing CAPTCHA/robot check');
              await browser.close();
              return [];
            }

            // Take screenshot for debugging
            try {
              await page.screenshot({ path: `/tmp/debug-${category}.png` });
              console.log(`üì∏ Debug screenshot saved`);
            } catch (e) {
              console.log('‚ö†Ô∏è  Could not take screenshot');
            }

            // Try multiple waiting strategies for content
            let booksFound = false;
            const selectorsToTry = [
              'div[data-component-type="s-search-result"]',
              '.s-result-item',
              '.zg-item-immersion',
              '.a-section.a-spacing-small'
            ];

            for (const selector of selectorsToTry) {
              try {
                await page.waitForSelector(selector, { timeout: 8000 });
                console.log(`‚úÖ Found elements with selector: ${selector}`);
                booksFound = true;
                break;
              } catch (e) {
                console.log(`‚ùå No elements with selector: ${selector}`);
              }
            }

            if (!booksFound) {
              console.log('‚ö†Ô∏è  No book elements found with any selector, trying to extract anyway...');
            }

            const books = await page.evaluate((category, affiliateId, currentYear) => {
              console.log('üîç Starting book extraction...');

              // Comprehensive selector strategy
              const selectors = [
                'div[data-component-type="s-search-result"]',
                '.s-result-item',
                '.zg-item-immersion',
                '.a-section.a-spacing-small'
              ];

              let allElements = [];
              for (const selector of selectors) {
                const elements = document.querySelectorAll(selector);
                if (elements.length > 0) {
                  console.log(`Found ${elements.length} elements with: ${selector}`);
                  allElements = Array.from(elements);
                  break;
                }
              }

              if (allElements.length === 0) {
                // Last resort: get any div that might contain books
                allElements = Array.from(document.querySelectorAll('div')).filter(div => 
                  div.textContent && div.textContent.length > 100
                );
                console.log(`Trying all divs: ${allElements.length} potential elements`);
              }

              const books = [];
              const processedTitles = new Set();

              allElements.forEach((element, index) => {
                if (index >= 15) return; // Limit to top 15

                try {
                  // Multiple title extraction strategies
                  let title = '';
                  const titleSelectors = [
                    'h2 a span',
                    '.a-size-medium.a-color-base.a-text-normal',
                    '.a-text-normal',
                    'h2',
                    '.a-link-normal span'
                  ];

                  for (const selector of titleSelectors) {
                    const titleEl = element.querySelector(selector);
                    if (titleEl && titleEl.textContent && titleEl.textContent.trim().length > 5) {
                      title = titleEl.textContent.trim();
                      break;
                    }
                  }

                  if (!title || title.length < 5 || processedTitles.has(title)) {
                    return;
                  }
                  processedTitles.add(title);

                  // Author extraction
                  let author = 'Unknown Author';
                  const authorSelectors = [
                    '.a-row.a-size-base',
                    '.a-size-base',
                    '.a-color-secondary',
                    '.a-text-normal'
                  ];

                  for (const selector of authorSelectors) {
                    const authorEl = element.querySelector(selector);
                    if (authorEl && authorEl.textContent) {
                      const authorText = authorEl.textContent.replace(/^by\s*/i, '').trim();
                      if (authorText && authorText.length > 2 && !authorText.includes('$')) {
                        author = authorText;
                        break;
                      }
                    }
                  }

                  // Price extraction
                  let price = 'Price not available';
                  const priceEl = element.querySelector('.a-price .a-offscreen, .a-price-range .a-offscreen');
                  if (priceEl && priceEl.textContent) {
                    price = priceEl.textContent.trim();
                  }

                  // Rating extraction
                  let rating = 4.0;
                  const ratingEl = element.querySelector('.a-icon-alt, .a-icon-star');
                  if (ratingEl && ratingEl.textContent) {
                    const match = ratingEl.textContent.match(/(\d+\.?\d*)/);
                    rating = match ? parseFloat(match[1]) : 4.0;
                  }

                  // Image extraction
                  let imageUrl = '';
                  const imgEl = element.querySelector('img');
                  if (imgEl) {
                    imageUrl = imgEl.src || imgEl.getAttribute('data-src') || '';
                  }

                  // ASIN extraction from URL
                  let asin = '';
                  const linkEl = element.querySelector('a[href*="/dp/"]');
                  if (linkEl && linkEl.href) {
                    const asinMatch = linkEl.href.match(/\/dp\/([A-Z0-9]{10})/);
                    asin = asinMatch ? asinMatch[1] : `book_${Date.now()}_${index}`;
                  } else {
                    asin = `book_${Date.now()}_${index}`;
                  }

                  books.push({
                    id: `book_${asin}_${Date.now()}`,
                    title: title,
                    author: author,
                    asin: asin,
                    price: price,
                    rating: rating,
                    imageUrl: imageUrl,
                    productUrl: `https://www.amazon.com/dp/${asin}?tag=${affiliateId}`,
                    category: category,
                    affiliateId: affiliateId,
                    scrapedAt: new Date().toISOString(),
                    bestsellerRank: index + 1,
                    year: currentYear,
                    categoryGroup: category.split('_')[0]
                  });

                } catch (error) {
                  console.log('Error parsing book element:', error.message);
                }
              });

              console.log(`‚úÖ Extracted ${books.length} books`);
              return books;

            }, category, AFFILIATE_ID, currentYear);

            await browser.close();
            
            if (books.length === 0) {
              console.log(`‚ùå No books extracted from ${category}`);
            } else {
              console.log(`‚úÖ Successfully extracted ${books.length} books from ${category}`);
            }
            
            return books;

          } catch (error) {
            console.log(`üí• Error scraping ${category}:`, error.message);
            try {
              await browser.close();
            } catch (e) {
              console.log('Browser already closed');
            }
            return [];
          }
        }

        // Main function
        async function main() {
          console.log('üöÄ Starting Focused Amazon Bestsellers Scraper');
          console.log('===================================================');
          console.log(`üìÖ Scraping ${currentYear} Bestsellers`);
          console.log(`üìö Categories: ${Object.keys(BESTSELLER_CATEGORIES).length}`);
          console.log(`üè∑Ô∏è  Affiliate ID: ${AFFILIATE_ID}`);
          console.log('===================================================\n');

          const existingData = loadExistingData();
          let categories = existingData.categories || {};
          const currentDate = new Date().toISOString().split('T')[0];

          let totalNewBooks = 0;
          let totalBooksScraped = 0;
          let categoriesProcessed = 0;

          const categoryEntries = Object.entries(BESTSELLER_CATEGORIES);
          
          for (let i = 0; i < categoryEntries.length; i++) {
            const [category, categoryUrl] = categoryEntries[i];
            categoriesProcessed++;
            
            console.log(`\nüìö Processing ${category} (${i + 1}/${categoryEntries.length})...`);

            const scrapedBooks = await scrapeBestsellersPage(category, categoryUrl);
            totalBooksScraped += scrapedBooks.length;

            if (!categories[category]) {
              categories[category] = [];
            }

            // Add only new books (check by ASIN)
            for (const book of scrapedBooks) {
              const existingBook = categories[category].find(b => b.asin === book.asin);
              
              if (!existingBook) {
                categories[category].push(book);
                totalNewBooks++;
                console.log(`‚ûï New: ${book.title.substring(0, 50)}...`);
              } else {
                // Update existing book's bestseller rank and date
                existingBook.bestsellerRank = book.bestsellerRank;
                existingBook.lastUpdated = currentDate;
                existingBook.previousRanks = existingBook.previousRanks || [];
                existingBook.previousRanks.push({
                  rank: book.bestsellerRank,
                  date: currentDate
                });
              }
            }

            // Add delay between categories to be respectful
            if (i < categoryEntries.length - 1) {
              const delayTime = 5000 + Math.random() * 3000; // 5-8 seconds
              console.log(`‚è≥ Waiting ${Math.round(delayTime/1000)} seconds before next category...`);
              await delay(delayTime);
            }
          }

          // Update metadata
          const totalBooks = Object.values(categories).reduce((sum, cat) => sum + cat.length, 0);

          const outputData = {
            lastUpdated: new Date().toISOString(),
            categories: categories,
            metadata: {
              totalBooks: totalBooks,
              categoriesCount: Object.keys(categories).length,
              affiliateId: AFFILIATE_ID,
              source: 'GitHub Actions Focused Bestsellers Scraper',
              scrapeYear: currentYear,
              exportDate: new Date().toISOString(),
              newBooksAdded: totalNewBooks,
              totalBooksScraped: totalBooksScraped,
              categoriesProcessed: categoriesProcessed,
              weeklyUpdate: true,
              totalCategoriesAvailable: Object.keys(BESTSELLER_CATEGORIES).length
            }
          };

          // Save to file
          fs.writeFileSync(OUTPUT_FILE, JSON.stringify(outputData, null, 2));

          console.log('\n==========================================');
          console.log('üéâ FOCUSED SCRAPING COMPLETE!');
          console.log('==========================================');
          console.log(`‚úÖ Categories processed: ${categoriesProcessed}`);
          console.log(`üìö Total books scraped this run: ${totalBooksScraped}`);
          console.log(`üÜï New books added: ${totalNewBooks}`);
          console.log(`üìä Total books in collection: ${totalBooks}`);
          console.log(`üìÖ Year: ${currentYear}`);
          console.log(`üíæ Data saved to: ${OUTPUT_FILE}`);
          console.log('==========================================\n');

          // Show summary by category
          console.log('üìñ BOOKS BY CATEGORY:');
          for (const [category, books] of Object.entries(categories)) {
            console.log(`   ${category}: ${books.length} books`);
          }
        }

        // Run the scraper
        main().catch(error => {
          console.error('üí• Fatal error:', error);
          process.exit(1);
        });
        EOF
        
    - name: Run focused bestsellers scraper
      env:
        AFFILIATE_ID: ${{ secrets.AMAZON_AFFILIATE_ID }}
      run: node bestsellers-scraper.js
      
    - name: Commit and push if changed
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add data/amazon-recommendations.json
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "üìö Update Amazon bestsellers - $(date +'%Y-%m-%d') [skip ci]"
          git push
        fi